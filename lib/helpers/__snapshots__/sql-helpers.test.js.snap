// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`_createInsertSQLJS std: with auto id 1`] = `
"/**
 * insert new unkeyed rows into codebase (no id field required, auto generated by db)
 * @param {codebaseVO[]} vos
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function createCodebase (vos) {
    let values = _.map(vos, (vo) => _.map([\\"groupId\\", \\"name\\", \\"description\\", \\"repoUrl\\"], (columnName) => vo[columnName]))
    return {
        query: \`INSERT INTO \\\\\`codebase\\\\\` (group_id, name, description, repo_url) VALUES ?\`,
        values: [values]
    }
}
exports.createCodebase = createCodebase"
`;

exports[`_createInsertSQLJS std: without auto id 1`] = `
"/**
 * insert new keyed rows into vulnerability (id field required, operation will fail without id, duplicate id inserts will be ignored)
 * @param {vulnerabilityVO[]} vos
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function createVulnerability (vos) {
    let values = _.map(vos, (vo) => _.map([\\"id\\", \\"typeId\\", \\"name\\"], (columnName) => vo[columnName]))
    return {
        query: \`INSERT INTO \\\\\`vulnerability\\\\\` (id, type_id, name) VALUES ? ON DUPLICATE KEY UPDATE id=id\`,
        values: [values]
    }
}
exports.createVulnerability = createVulnerability"
`;

exports[`_createTableJoinQueriesAndTypeDef std 1`] = `
"/**
 * Database Value Object for table join of 'codebase' to 'scan'
 * @typedef {Object} codebaseWithScanVO
 * @property {number} id - Primary ID, 'id' Column on codebase
 * @property {number} groupId - 'group_id' Column on codebase
 * @property {number} latestScanId - Scan ID for the main branch latest scan, 'latest_scan_id' Column on codebase
 * @property {string} name - 'name' Column on codebase
 * @property {string} description - 'description' Column on codebase
 * @property {string} repoUrl - 'repo_url' Column on codebase
 * @property {string} lastUpdated - 'last_updated' Column on codebase
 * @property {number} codebasebranchId - 'codebasebranch_id' Column on scan
 * @property {string} date - scan date, 'date' Column on scan
 * @property {number} duration - scan duration, 'duration' Column on scan
 * @property {string} reportS3Key - 'report_s3_key' Column on scan
 * @property {number} status - 'status' Column on scan
 * @property {number} scaState - 'sca_state' Column on scan
 * @property {number} sastState - 'sast_state' Column on scan
 * @property {number} secretsState - 'secrets_state' Column on scan
 * @property {number} sbomState - 'sbom_state' Column on scan
 * @property {number} critical - 'critical' Column on scan
 * @property {number} high - 'high' Column on scan
 * @property {number} medium - 'medium' Column on scan
 * @property {number} na - 'na' Column on scan
 * @property {number} none - 'none' Column on scan
 * @property {number} total - 'total' Column on scan
 */

/**
 * @param {string} id
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebaseByIdWithScan (id) {
    return {
        query: \`SELECT \\\\\`codebase\\\\\`.id as id,\\\\\`codebase\\\\\`.group_id as groupId,\\\\\`codebase\\\\\`.latest_scan_id as latestScanId,\\\\\`codebase\\\\\`.name as name,\\\\\`codebase\\\\\`.description as description,\\\\\`codebase\\\\\`.repo_url as repoUrl,\\\\\`codebase\\\\\`.last_updated as lastUpdated,\\\\\`scan\\\\\`.codebasebranch_id as codebasebranchId,\\\\\`scan\\\\\`.date as date,\\\\\`scan\\\\\`.duration as duration,\\\\\`scan\\\\\`.report_s3_key as reportS3Key,\\\\\`scan\\\\\`.status as status,\\\\\`scan\\\\\`.sca_state as scaState,\\\\\`scan\\\\\`.sast_state as sastState,\\\\\`scan\\\\\`.secrets_state as secretsState,\\\\\`scan\\\\\`.sbom_state as sbomState,\\\\\`scan\\\\\`.critical as critical,\\\\\`scan\\\\\`.high as high,\\\\\`scan\\\\\`.medium as medium,\\\\\`scan\\\\\`.na as na,\\\\\`scan\\\\\`.none as none,\\\\\`scan\\\\\`.total as total FROM \\\\\`codebase\\\\\`
LEFT JOIN \\\\\`scan\\\\\`
ON \\\\\`codebase\\\\\`.latest_scan_id = \\\\\`scan\\\\\`.id
WHERE \\\\\`codebase\\\\\`.id = ?\`,
        values: [id]
    }
}
exports.readCodebaseByIdWithScan = readCodebaseByIdWithScan

/**
 * @param {Object.<string, string>[]} [orderColumns] array key-value of columns to order and how by aka [{\\"id\\":\\"ASC\\"}, {\\"time\\":\\"DESC\\"}]
 * @param {number} [rowCount]
 * @param {number} [offset]
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebasesWithScan (orderColumns=null, rowCount=100, offset=0) {
    orderColumns = orderColumns || [{'id': 'ASC'}]
    let orderColumnsKV = _.map(orderColumns, (columnDef) => _.first(_.map(columnDef, (value, key) => ({ key, value }))))
    return {
        query: \`SELECT \\\\\`codebase\\\\\`.id as id,\\\\\`codebase\\\\\`.group_id as groupId,\\\\\`codebase\\\\\`.latest_scan_id as latestScanId,\\\\\`codebase\\\\\`.name as name,\\\\\`codebase\\\\\`.description as description,\\\\\`codebase\\\\\`.repo_url as repoUrl,\\\\\`codebase\\\\\`.last_updated as lastUpdated,\\\\\`scan\\\\\`.codebasebranch_id as codebasebranchId,\\\\\`scan\\\\\`.date as date,\\\\\`scan\\\\\`.duration as duration,\\\\\`scan\\\\\`.report_s3_key as reportS3Key,\\\\\`scan\\\\\`.status as status,\\\\\`scan\\\\\`.sca_state as scaState,\\\\\`scan\\\\\`.sast_state as sastState,\\\\\`scan\\\\\`.secrets_state as secretsState,\\\\\`scan\\\\\`.sbom_state as sbomState,\\\\\`scan\\\\\`.critical as critical,\\\\\`scan\\\\\`.high as high,\\\\\`scan\\\\\`.medium as medium,\\\\\`scan\\\\\`.na as na,\\\\\`scan\\\\\`.none as none,\\\\\`scan\\\\\`.total as total FROM \\\\\`codebase\\\\\`
LEFT JOIN \\\\\`scan\\\\\`
ON \\\\\`codebase\\\\\`.latest_scan_id = \\\\\`scan\\\\\`.id
ORDER BY \${_.map(orderColumnsKV, (o) => sane(o.key) + ' ' + sane(o.value)).join(', ')} LIMIT ? OFFSET ?\`,
        values: [rowCount, offset]
    }
}
exports.readCodebasesWithScan = readCodebasesWithScan

/**
 * @param {Object.<string, string>} columnValues key-value of columns to select by aka {\\"tool_scan\\":123}
 * @param {Object.<string, string>[]} [orderColumns] array key-value of columns to order and how by aka [{\\"id\\":\\"ASC\\"}, {\\"time\\":\\"DESC\\"}]
 * @param {number} [rowCount]
 * @param {number} [offset]
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebasesByColumnWithScan (columnValues, orderColumns=null, rowCount=100, offset=0) {
    if(!_.values(columnValues).length) {
        throw new Error('No columns given to ByColumn function')
    }
    orderColumns = orderColumns || [{'id': 'ASC'}]
    let orderColumnsKV = _.map(orderColumns, (columnDef) => _.first(_.map(columnDef, (value, key) => ({ key, value }))))

    let table = \\"\`codebase\`\\"
    return {
        query: \`SELECT \\\\\`codebase\\\\\`.id as id,\\\\\`codebase\\\\\`.group_id as groupId,\\\\\`codebase\\\\\`.latest_scan_id as latestScanId,\\\\\`codebase\\\\\`.name as name,\\\\\`codebase\\\\\`.description as description,\\\\\`codebase\\\\\`.repo_url as repoUrl,\\\\\`codebase\\\\\`.last_updated as lastUpdated,\\\\\`scan\\\\\`.codebasebranch_id as codebasebranchId,\\\\\`scan\\\\\`.date as date,\\\\\`scan\\\\\`.duration as duration,\\\\\`scan\\\\\`.report_s3_key as reportS3Key,\\\\\`scan\\\\\`.status as status,\\\\\`scan\\\\\`.sca_state as scaState,\\\\\`scan\\\\\`.sast_state as sastState,\\\\\`scan\\\\\`.secrets_state as secretsState,\\\\\`scan\\\\\`.sbom_state as sbomState,\\\\\`scan\\\\\`.critical as critical,\\\\\`scan\\\\\`.high as high,\\\\\`scan\\\\\`.medium as medium,\\\\\`scan\\\\\`.na as na,\\\\\`scan\\\\\`.none as none,\\\\\`scan\\\\\`.total as total FROM \\\\\`codebase\\\\\`
LEFT JOIN \\\\\`scan\\\\\`
ON \\\\\`codebase\\\\\`.latest_scan_id = \\\\\`scan\\\\\`.id
WHERE \${_.map(columnValues, (value, column) => table + '.' + sane(column) + ' = ?').join(' AND ')}
ORDER BY \${_.map(orderColumnsKV, (o) => sane(o.key) + ' ' + sane(o.value)).join(', ')} LIMIT ? OFFSET ?\`,
        values: _.map(columnValues, (value) => value).concat([ rowCount, offset])
    }
}
exports.readCodebasesByColumnWithScan = readCodebasesByColumnWithScan
"
`;

exports[`_createTableQueriesAndTypeDef std 1`] = `
"/**
 * Database Value Object for table 'codebase'
 * @typedef {Object} codebaseVO
 * @property {number} id - Primary ID, 'id' Column on codebase
 * @property {number} groupId - 'group_id' Column on codebase
 * @property {string} name - 'name' Column on codebase
 * @property {string} description - 'description' Column on codebase
 * @property {string} repoUrl - 'repo_url' Column on codebase
 * @property {string} lastUpdated - 'last_updated' Column on codebase
 */
const CODEBASE_DEF = {
  \\"table\\": \\"codebase\\",
  \\"hasAutoIds\\": true,
  \\"columns\\": [
    {
      \\"isPrimary\\": true,
      \\"isSystem\\": false,
      \\"isOptional\\": true,
      \\"jsDataType\\": \\"number\\",
      \\"jsField\\": \\"id\\",
      \\"sqlField\\": \\"id\\",
      \\"comment\\": \\"Primary ID, 'id' Column on codebase\\"
    },
    {
      \\"isPrimary\\": false,
      \\"isSystem\\": false,
      \\"isOptional\\": true,
      \\"jsDataType\\": \\"number\\",
      \\"jsField\\": \\"groupId\\",
      \\"sqlField\\": \\"group_id\\",
      \\"comment\\": \\"'group_id' Column on codebase\\"
    },
    {
      \\"isPrimary\\": false,
      \\"isSystem\\": false,
      \\"isOptional\\": true,
      \\"jsDataType\\": \\"string\\",
      \\"jsField\\": \\"name\\",
      \\"sqlField\\": \\"name\\",
      \\"comment\\": \\"'name' Column on codebase\\"
    },
    {
      \\"isPrimary\\": false,
      \\"isSystem\\": false,
      \\"isOptional\\": true,
      \\"jsDataType\\": \\"string\\",
      \\"jsField\\": \\"description\\",
      \\"sqlField\\": \\"description\\",
      \\"comment\\": \\"'description' Column on codebase\\"
    },
    {
      \\"isPrimary\\": false,
      \\"isSystem\\": false,
      \\"isOptional\\": true,
      \\"jsDataType\\": \\"string\\",
      \\"jsField\\": \\"repoUrl\\",
      \\"sqlField\\": \\"repo_url\\",
      \\"comment\\": \\"'repo_url' Column on codebase\\"
    },
    {
      \\"isPrimary\\": false,
      \\"isSystem\\": true,
      \\"isOptional\\": false,
      \\"jsDataType\\": \\"string\\",
      \\"jsField\\": \\"lastUpdated\\",
      \\"sqlField\\": \\"last_updated\\",
      \\"comment\\": \\"'last_updated' Column on codebase\\"
    }
  ],
  \\"primary\\": {
    \\"isPrimary\\": true,
    \\"isSystem\\": false,
    \\"isOptional\\": true,
    \\"jsDataType\\": \\"number\\",
    \\"jsField\\": \\"id\\",
    \\"sqlField\\": \\"id\\",
    \\"comment\\": \\"Primary ID, 'id' Column on codebase\\"
  }
}
exports.CODEBASE_DEF = CODEBASE_DEF

/**
 * insert new unkeyed rows into codebase (no id field required, auto generated by db)
 * @param {codebaseVO[]} vos
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function createCodebase (vos) {
    let values = _.map(vos, (vo) => _.map([\\"groupId\\", \\"name\\", \\"description\\", \\"repoUrl\\"], (columnName) => vo[columnName]))
    return {
        query: \`INSERT INTO \\\\\`codebase\\\\\` (group_id, name, description, repo_url) VALUES ?\`,
        values: [values]
    }
}
exports.createCodebase = createCodebase

/**
 * @param {codebaseVO} vo partially populated, requires 'id' field populated
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function updateCodebase (vo) {
    let updatableColumns = [{\\"jsField\\":\\"groupId\\",\\"sqlField\\":\\"group_id\\"},{\\"jsField\\":\\"name\\",\\"sqlField\\":\\"name\\"},{\\"jsField\\":\\"description\\",\\"sqlField\\":\\"description\\"},{\\"jsField\\":\\"repoUrl\\",\\"sqlField\\":\\"repo_url\\"}]
    let columnsToUpdate = _.filter(updatableColumns, (c) => c.jsField in vo)
    let values = _.map(columnsToUpdate, (c) => vo[c.jsField])
    values.push(vo.id)
    return {
        query: \`UPDATE \\\\\`codebase\\\\\` SET \${_.map(columnsToUpdate, (c) => c.sqlField + ' = ?').join(', ')} WHERE id = ?\`,
        values: values
    }
}
exports.updateCodebase = updateCodebase

/**
 * @param {codebaseVO} vo partially populated, requires 'id' field populated
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function deleteCodebase (vo) {
    return {
        query: \`DELETE FROM \\\\\`codebase\\\\\` WHERE id = ?\`,
        values: [vo.id]
    }
}
exports.deleteCodebase = deleteCodebase

/**
 * @param {string} id
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebaseById (id) {
    return {
        query: \`SELECT id as id,group_id as groupId,name as name,description as description,repo_url as repoUrl,last_updated as lastUpdated FROM \\\\\`codebase\\\\\` WHERE id = ?\`,
        values: [id]
    }
}
exports.readCodebaseById = readCodebaseById

/**
 * @param {Object.<string, string>[]} [orderColumns] array key-value of columns to order and how by aka [{\\"id\\":\\"ASC\\"}, {\\"time\\":\\"DESC\\"}]
 * @param {number} [rowCount]
 * @param {number} [offset]
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebases (orderColumns=null, rowCount=100, offset=0) {
    orderColumns = orderColumns || [{'id': 'ASC'}]
    let orderColumnsKV = _.map(orderColumns, (columnDef) => _.first(_.map(columnDef, (value, key) => ({ key, value }))))
    return {
        query: \`SELECT id as id,group_id as groupId,name as name,description as description,repo_url as repoUrl,last_updated as lastUpdated FROM \\\\\`codebase\\\\\`
ORDER BY \${_.map(orderColumnsKV, (o) => sane(o.key) + ' ' + sane(o.value)).join(', ')} LIMIT ? OFFSET ?\`,
        values: [rowCount, offset]
    }
}
exports.readCodebases = readCodebases

/**
 * @param {Object.<string, string>} columnValues key-value of columns to select by aka {\\"tool_scan\\":123}
 * @param {Object.<string, string>[]} [orderColumns] array key-value of columns to order and how by aka [{\\"id\\":\\"ASC\\"}, {\\"time\\":\\"DESC\\"}]
 * @param {number} [rowCount]
 * @param {number} [offset]
 * @returns {{query: string, values: Array}} prepared statement query and values for it
 */
function readCodebasesByColumn (columnValues, orderColumns=null, rowCount=100, offset=0) {
    if(!_.values(columnValues).length) {
        throw new Error('No columns given to ByColumn function')
    }
    orderColumns = orderColumns || [{'id': 'ASC'}]
    let orderColumnsKV = _.map(orderColumns, (columnDef) => _.first(_.map(columnDef, (value, key) => ({ key, value }))))
    return {
        query: \`SELECT id as id,group_id as groupId,name as name,description as description,repo_url as repoUrl,last_updated as lastUpdated FROM \\\\\`codebase\\\\\`
WHERE \${_.map(columnValues, (value, column) => sane(column) + ' = ?').join(' AND ')}
ORDER BY \${_.map(orderColumnsKV, (o) => sane(o.key) + ' ' + sane(o.value)).join(', ')} LIMIT ? OFFSET ?\`,
        values: _.map(columnValues, (value) => value).concat([rowCount, offset])
    }
}
exports.readCodebasesByColumn = readCodebasesByColumn
"
`;
